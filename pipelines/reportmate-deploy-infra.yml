# Azure DevOps CI/CD Pipeline for ReportMate
# Unified pipeline that handles infrastructure, containers, and applications

trigger:
  branches:
    include:
      - main
      - develop
  paths:
    include:
      - apps/www/**
      - functions/**
      - infrastructure/**
      - pipelines/**

variables:
  vmImageName: 'ubuntu-latest'
  azureSubscription: 'your-service-connection-name' # Update this
  
  # Resource Configuration
  resourceGroupName: 'ReportMate'
  containerRegistryName: 'reportmateacr'
  functionAppName: 'reportmate-api'
  frontendContainerAppName: 'reportmate-frontend'
  
  # Terraform Backend Configuration
  terraformBackendResourceGroup: 'tfstate-rg'
  terraformBackendStorageAccount: 'tfstatestorage'
  terraformBackendContainerName: 'tfstate'
  terraformBackendKey: 'reportmate.tfstate'
  
  # Build Configuration
  nodeVersion: '18.x'
  pythonVersion: '3.12'
  
  # Container Images
  frontendImageName: 'reportmate'
  functionsImageName: 'reportmate-functions'

pool:
  vmImage: $(vmImageName)

stages:
  - stage: Build
    displayName: 'Build Applications'
    jobs:
      - job: BuildApps
        displayName: 'Build Frontend and Functions'
        steps:
          # Setup Tools
          - task: NodeTool@0
            displayName: 'Setup Node.js'
            inputs:
              versionSpec: $(nodeVersion)
          
          - task: UsePythonVersion@0
            displayName: 'Setup Python'
            inputs:
              versionSpec: $(pythonVersion)
              addToPath: true
          
          - script: npm install -g pnpm
            displayName: 'Install pnpm'
          
          # Build Next.js Frontend
          - script: |
              cd apps/www
              pnpm install --frozen-lockfile
              pnpm run build
            displayName: 'Build Next.js Frontend'
          
          # Install Function Dependencies
          - script: |
              cd functions
              pip install -r requirements.txt
            displayName: 'Install Function Dependencies'
          
          # Copy Infrastructure Files
          - task: CopyFiles@2
            displayName: 'Copy Infrastructure Files'
            inputs:
              SourceFolder: '$(Build.SourcesDirectory)'
              Contents: |
                infrastructure/**
                scripts/**
                azure.yaml
                docker-compose.yml
              TargetFolder: '$(Build.ArtifactStagingDirectory)/infra'
          
          # Archive Functions for Traditional Deployment (Backup)
          - task: ArchiveFiles@2
            displayName: 'Archive Functions Package'
            inputs:
              rootFolderOrFile: 'functions'
              includeRootFolder: false
              archiveType: 'zip'
              archiveFile: '$(Build.ArtifactStagingDirectory)/functions.zip'
          
          - task: PublishBuildArtifacts@1
            displayName: 'Publish Build Artifacts'
            inputs:
              pathToPublish: '$(Build.ArtifactStagingDirectory)'
              artifactName: 'drop'

  - stage: Infrastructure
    displayName: 'Deploy Infrastructure'
    dependsOn: Build
    jobs:
      - deployment: DeployTerraform
        displayName: 'Deploy Terraform Infrastructure'
        environment: 'Production'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadBuildArtifacts@0
                  displayName: 'Download Infrastructure Files'
                  inputs:
                    buildType: 'current'
                    downloadType: 'single'
                    artifactName: 'drop'
                    downloadPath: '$(System.ArtifactsDirectory)'
                
                - script: |
                    # Install Terraform
                    wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg
                    echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
                    sudo apt update && sudo apt install terraform
                  displayName: 'Install Terraform'
                
                - task: AzureCLI@2
                  displayName: 'Deploy Infrastructure with Terraform'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      cd $(System.ArtifactsDirectory)/drop/infra/infrastructure
                      
                      # Initialize Terraform
                      terraform init \
                        -backend-config="resource_group_name=$(terraformBackendResourceGroup)" \
                        -backend-config="storage_account_name=$(terraformBackendStorageAccount)" \
                        -backend-config="container_name=$(terraformBackendContainerName)" \
                        -backend-config="key=$(terraformBackendKey)"
                      
                      # Validate and plan
                      terraform validate
                      terraform plan -var="db_password=$(DB_PASSWORD)" -out=tfplan
                      
                      # Apply infrastructure changes
                      terraform apply -auto-approve tfplan
                      
                      # Extract outputs for later stages
                      terraform output -json > $(Build.ArtifactStagingDirectory)/terraform-outputs.json
                      
                      echo "=== Infrastructure Deployment Complete ==="
                      echo "Resource Group: $(resourceGroupName)"
                      echo "Container Registry: $(containerRegistryName).azurecr.io"
                
                - task: PublishBuildArtifacts@1
                  displayName: 'Publish Terraform Outputs'
                  inputs:
                    pathToPublish: '$(Build.ArtifactStagingDirectory)/terraform-outputs.json'
                    artifactName: 'terraform-outputs'

  - stage: Containers
    displayName: 'Build & Deploy Containers'
    dependsOn: Infrastructure
    jobs:
      - job: BuildContainers
        displayName: 'Build Container Images'
        steps:
          # Login to Azure Container Registry
          - task: AzureCLI@2
            displayName: 'Login to Container Registry'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az acr login --name $(containerRegistryName)
          
          # Build and Push Frontend Container
          - task: Docker@2
            displayName: 'Build Frontend Container'
            inputs:
              command: 'build'
              Dockerfile: 'apps/www/Dockerfile'
              buildContext: 'apps/www'
              repository: '$(containerRegistryName).azurecr.io/$(frontendImageName)'
              arguments: '--build-arg DOCKER_BUILD=true'
              tags: |
                latest
                $(Build.BuildNumber)
          
          - task: Docker@2
            displayName: 'Push Frontend Container'
            inputs:
              command: 'push'
              repository: '$(containerRegistryName).azurecr.io/$(frontendImageName)'
              tags: |
                latest
                $(Build.BuildNumber)
          
          # Build and Push Functions Container
          - task: Docker@2
            displayName: 'Build Functions Container'
            inputs:
              command: 'build'
              Dockerfile: 'functions/Dockerfile'
              buildContext: 'functions'
              repository: '$(containerRegistryName).azurecr.io/$(functionsImageName)'
              tags: |
                latest
                $(Build.BuildNumber)
          
          - task: Docker@2
            displayName: 'Push Functions Container'
            inputs:
              command: 'push'
              repository: '$(containerRegistryName).azurecr.io/$(functionsImageName)'
              tags: |
                latest
                $(Build.BuildNumber)

      - deployment: DeployContainers
        displayName: 'Deploy Container Apps'
        dependsOn: BuildContainers
        environment: 'Production'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadBuildArtifacts@0
                  displayName: 'Download Infrastructure Files'
                  inputs:
                    buildType: 'current'
                    downloadType: 'specific'
                    itemPattern: |
                      drop/infra/infrastructure/**
                      drop/infra/scripts/**
                      terraform-outputs/**
                    downloadPath: '$(System.ArtifactsDirectory)'
                
                - task: AzureCLI@2
                  displayName: 'Update Container Apps'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      cd $(System.ArtifactsDirectory)/drop/infra/infrastructure
                      
                      # Initialize Terraform (reuse existing state)
                      terraform init \
                        -backend-config="resource_group_name=$(terraformBackendResourceGroup)" \
                        -backend-config="storage_account_name=$(terraformBackendStorageAccount)" \
                        -backend-config="container_name=$(terraformBackendContainerName)" \
                        -backend-config="key=$(terraformBackendKey)"
                      
                      # Update container apps with new image tags
                      terraform apply -auto-approve \
                        -var="db_password=$(DB_PASSWORD)"
                      
                      echo "=== Container Apps Updated ==="
                      
                      # Get deployment URLs
                      FRONTEND_URL=$(terraform output -raw frontend_url 2>/dev/null || echo "N/A")
                      FUNCTION_URL=$(terraform output -raw function_app_url 2>/dev/null || echo "N/A")
                      PUBSUB_URL=$(terraform output -raw web_pubsub_endpoint 2>/dev/null || echo "N/A")
                      
                      echo "Frontend: $FRONTEND_URL"
                      echo "Functions: $FUNCTION_URL"
                      echo "WebPubSub: wss://$PUBSUB_URL/client/hubs/events"
                      
                      # Store URLs for testing stage
                      echo "##vso[task.setvariable variable=FrontendUrl;isOutput=true]$FRONTEND_URL"
                      echo "##vso[task.setvariable variable=FunctionUrl;isOutput=true]$FUNCTION_URL"
                
                - task: AzureCLI@2
                  displayName: 'Setup Database Schema'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      # Install PostgreSQL client
                      sudo apt-get update && sudo apt-get install -y postgresql-client
                      
                      # Get database connection info
                      DB_HOST=$(az postgres flexible-server show \
                        --name reportmate-database \
                        --resource-group $(resourceGroupName) \
                        --query "fullyQualifiedDomainName" \
                        --output tsv 2>/dev/null || echo "")
                      
                      if [ -n "$DB_HOST" ]; then
                        DB_URL="postgresql://reportmate:$(DB_PASSWORD)@$DB_HOST:5432/reportmate?sslmode=require"
                        
                        # Run database initialization
                        psql "$DB_URL" << 'EOF'
                          CREATE TABLE IF NOT EXISTS events (
                              id VARCHAR(255) PRIMARY KEY,
                              device VARCHAR(255) NOT NULL,
                              kind VARCHAR(100) NOT NULL,
                              ts TIMESTAMP WITH TIME ZONE NOT NULL,
                              payload JSONB,
                              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
                          );
                          
                          CREATE TABLE IF NOT EXISTS cimian_runs (
                              id VARCHAR(255) PRIMARY KEY,
                              device VARCHAR(255) NOT NULL,
                              ts TIMESTAMP WITH TIME ZONE NOT NULL,
                              exit_code INTEGER,
                              duration INTEGER,
                              details TEXT,
                              created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
                          );
                          
                          CREATE INDEX IF NOT EXISTS idx_events_device_ts ON events(device, ts DESC);
                          CREATE INDEX IF NOT EXISTS idx_events_kind_ts ON events(kind, ts DESC);
                          CREATE INDEX IF NOT EXISTS idx_cimian_runs_device_ts ON cimian_runs(device, ts DESC);
                        EOF
                        
                        echo "Database schema updated successfully"
                      else
                        echo "Database not found, skipping schema setup"
                      fi

  - stage: DeployFunctions
    displayName: 'Deploy Azure Functions'
    dependsOn: Infrastructure
    jobs:
      - deployment: DeployFunctionApp
        displayName: 'Deploy Functions to Azure'
        environment: 'Production'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadBuildArtifacts@0
                  displayName: 'Download Build Artifacts'
                  inputs:
                    buildType: 'current'
                    downloadType: 'specific'
                    itemPattern: 'drop/functions.zip'
                    downloadPath: '$(System.ArtifactsDirectory)'
                
                - task: UsePythonVersion@0
                  displayName: 'Setup Python'
                  inputs:
                    versionSpec: $(pythonVersion)
                    addToPath: true
                
                # Install Azure Functions Core Tools
                - script: |
                    wget -q https://packages.microsoft.com/config/ubuntu/$(lsb_release -rs)/packages-microsoft-prod.deb
                    sudo dpkg -i packages-microsoft-prod.deb
                    sudo apt-get update
                    sudo apt-get install -y azure-functions-core-tools-4
                  displayName: 'Install Azure Functions Core Tools v4'
                
                # Extract and prepare the functions package
                - script: |
                    mkdir -p $(Build.ArtifactStagingDirectory)/functions-deploy
                    cd $(Build.ArtifactStagingDirectory)/functions-deploy
                    unzip -q $(System.ArtifactsDirectory)/drop/functions.zip
                    
                    # Install Python dependencies with native builds
                    python -m pip install --upgrade pip
                    pip install --target ./.python_packages/lib/site-packages -r requirements.txt
                  displayName: 'Prepare Function Package'
                
                # Package the function app
                - script: |
                    cd $(Build.ArtifactStagingDirectory)/functions-deploy
                    func pack --build-native-deps --python --output $(Build.ArtifactStagingDirectory)/functionsapp.zip
                  displayName: 'Package Function App'
                
                # Deploy to Azure Function App
                - task: AzureFunctionApp@1
                  displayName: 'Deploy to Azure Functions'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    appType: 'functionAppLinux'
                    appName: $(functionAppName)
                    package: '$(Build.ArtifactStagingDirectory)/functionsapp.zip'
                    runtimeStack: 'PYTHON|$(pythonVersion)'
                    deploymentMethod: 'zipDeploy'
                
                # Configure Function App Settings
                - task: AzureCLI@2
                  displayName: 'Configure Function App Settings'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      echo "Configuring function app settings..."
                      
                      # Get the API URL and other settings from Terraform outputs or environment
                      API_URL="https://reportmate-functions-api.blackdune-79551938.canadacentral.azurecontainerapps.io"
                      
                      # Set application settings
                      az functionapp config appsettings set \
                        --name $(functionAppName) \
                        --resource-group $(resourceGroupName) \
                        --settings \
                          "REPORTMATE_API_URL=$API_URL" \
                          "REPORTMATE_API_KEY=$(REPORTMATE_API_KEY)" \
                          "TEAMS_WEBHOOK_URL=$(TEAMS_WEBHOOK_URL)" \
                          "FUNCTIONS_WORKER_RUNTIME=python" \
                          "PYTHON_VERSION=$(pythonVersion)" \
                          "ENABLE_ORYX_BUILD=false" \
                          "SCM_DO_BUILD_DURING_DEPLOYMENT=false"
                      
                      echo "Function app settings configured successfully"
                
                # Verify deployment
                - task: AzureCLI@2
                  displayName: 'Verify Function Deployment'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: 'bash'
                    scriptLocation: 'inlineScript'
                    inlineScript: |
                      FUNCTION_URL=$(az functionapp show \
                        --name $(functionAppName) \
                        --resource-group $(resourceGroupName) \
                        --query "defaultHostName" \
                        --output tsv)
                      
                      echo "Function App URL: https://$FUNCTION_URL"
                      
                      # List deployed functions
                      echo "Listing deployed functions..."
                      az functionapp function list \
                        --name $(functionAppName) \
                        --resource-group $(resourceGroupName) \
                        --query "[].{Name:name, Trigger:config.bindings[0].type}" \
                        --output table || echo "Functions list not yet available"
                      
                      # Store URL for testing stage
                      echo "##vso[task.setvariable variable=FunctionAppUrl;isOutput=true]$FUNCTION_URL"

  - stage: Test
    displayName: 'Health Check & Validation'
    dependsOn: 
      - Containers
      - DeployFunctions
    jobs:
      - job: HealthCheck
        displayName: 'Test Deployed Applications'
        steps:
          - task: AzureCLI@2
            displayName: 'Health Check All Services'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Starting health checks..."
                
                # Get application URLs
                FRONTEND_URL=$(az containerapp show \
                  --name $(frontendContainerAppName) \
                  --resource-group $(resourceGroupName) \
                  --query "properties.configuration.ingress.fqdn" \
                  --output tsv 2>/dev/null || echo "")
                
                FUNCTION_URL=$(az functionapp show \
                  --name $(functionAppName) \
                  --resource-group $(resourceGroupName) \
                  --query "defaultHostName" \
                  --output tsv 2>/dev/null || echo "")
                
                # Test Frontend
                if [ -n "$FRONTEND_URL" ]; then
                  echo "Testing frontend at: https://$FRONTEND_URL"
                  FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$FRONTEND_URL" || echo "000")
                  
                  if [ "$FRONTEND_STATUS" = "200" ]; then
                    echo "[OK] Frontend is healthy (Status: $FRONTEND_STATUS)"
                  else
                    echo "[WARN] Frontend health check warning (Status: $FRONTEND_STATUS)"
                  fi
                else
                  echo "Frontend URL not found"
                fi
                
                # Test Functions API
                if [ -n "$FUNCTION_URL" ]; then
                  echo "Testing functions at: https://$FUNCTION_URL"
                  
                  # Test health/storage alert function
                  sleep 10  # Give functions time to warm up
                  
                  HEALTH_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$FUNCTION_URL/api/health" 2>/dev/null || echo "000")
                  
                  if [ "$HEALTH_STATUS" = "200" ] || [ "$HEALTH_STATUS" = "404" ]; then
                    echo "[OK] Functions API is accessible (Status: $HEALTH_STATUS)"
                    
                    # List functions to verify storage alert is deployed
                    echo "Checking for deployed functions..."
                    FUNCTIONS=$(az functionapp function list \
                      --name $(functionAppName) \
                      --resource-group $(resourceGroupName) \
                      --query "[].name" \
                      --output tsv 2>/dev/null || echo "")
                    
                    if [ -n "$FUNCTIONS" ]; then
                      echo "Deployed functions:"
                      echo "$FUNCTIONS"
                      
                      # Check if storage alert function exists
                      if echo "$FUNCTIONS" | grep -q "reportmate_storage_alerts"; then
                        echo "[OK] Storage alert function deployed successfully"
                      else
                        echo "[WARN] Storage alert function not found in deployment"
                      fi
                    else
                      echo "[WARN] Could not retrieve function list"
                    fi
                  else
                    echo "[WARN] Functions API health check warning (Status: $HEALTH_STATUS)"
                  fi
                else
                  echo "Functions URL not found"
                fi
                
                echo ""
                echo "======================================"
                echo "Deployment Summary"
                echo "======================================"
                echo "Build Number: $(Build.BuildId)"
                echo "Frontend: ${FRONTEND_URL:-'Not deployed'}"
                echo "Functions: ${FUNCTION_URL:-'Not deployed'}"
                echo "Container Registry: $(containerRegistryName).azurecr.io"
                echo "Resource Group: $(resourceGroupName)"
                echo ""
                echo "[OK] Unified pipeline deployment completed successfully!"

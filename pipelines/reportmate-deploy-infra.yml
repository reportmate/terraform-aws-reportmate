# =============================================================================
# ReportMate CI/CD Pipeline
# =============================================================================
# 
# Architecture: Terraform is the single source of truth
#   1. Pipeline builds Docker images from GitHub repos
#   2. Pushes to Azure Container Registry (reportmateacr.azurecr.io)
#   3. Terraform deploys container apps with image tags passed as -var
#
# Source Repos:
#   - API Container: github.com/reportmate/terraform-azurerm-reportmate
#     Dockerfile: infrastructure/modules/api/Dockerfile
#   - Frontend Container: github.com/reportmate/reportmate-app-web
#     Dockerfile: Dockerfile (root)
#
# TRIGGERS:
#   - Push to main on reportmate/terraform-azurerm-reportmate (infra repo)
#   - Push to main on reportmate/reportmate-app-web (webapp repo)
#   - Manual run via Azure DevOps
# =============================================================================

# NOTE: This pipeline is triggered by EXTERNAL GitHub repos, not this internal repo.
# The trigger/pr sections below are disabled because we use resource triggers instead.
trigger: none
pr: none

# =============================================================================
# RESOURCES - External GitHub Repos with Triggers
# =============================================================================
resources:
  repositories:
    # Infrastructure repo (contains API code and Terraform)
    - repository: infrastructure
      type: github
      name: reportmate/terraform-azurerm-reportmate
      endpoint: 'GitHub-ReportMate'  # UPDATE: Your GitHub service connection
      ref: main
      trigger:
        branches:
          include:
            - main
        paths:
          include:
            - infrastructure/**
            - modules/**
    
    # Web App source (frontend Next.js app)
    - repository: webapp
      type: github
      name: reportmate/reportmate-app-web
      endpoint: 'GitHub-ReportMate'  # UPDATE: Your GitHub service connection
      ref: main
      trigger:
        branches:
          include:
            - main
        paths:
          include:
            - '**'  # Any change triggers frontend build

# =============================================================================
# PIPELINE PARAMETERS
# =============================================================================
parameters:
  - name: environment
    displayName: Target Environment
    type: string
    default: prod
    values:
      - prod
      - dev

  - name: forceBuild
    displayName: Force Rebuild (no Docker cache)
    type: boolean
    default: false

  - name: deployFrontend
    displayName: Build & Deploy Frontend Container
    type: boolean
    default: true

  - name: deployApi
    displayName: Build & Deploy API Container
    type: boolean
    default: true

  - name: skipTerraform
    displayName: Skip Terraform (build & push only)
    type: boolean
    default: false

  - name: purgeOnly
    displayName: Purge CDN Only (no build/deploy)
    type: boolean
    default: false

# =============================================================================
# VARIABLES
# =============================================================================
variables:
  # Azure Configuration
  azureSubscription: 'ReportMate-ServiceConnection'  # UPDATE: Your service connection
  resourceGroup: 'ReportMate'
  containerRegistry: 'reportmateacr'
  registryUrl: 'reportmateacr.azurecr.io'
  
  # Container Apps (must match Terraform resource names)
  frontendContainerApp: 'reportmate-web-app-prod'
  apiContainerApp: 'reportmate-functions-api'
  
  # Image Names (in ACR)
  frontendImage: 'reportmate'
  apiImage: 'reportmate-api'
  
  # Domain Configuration
  customDomain: 'reportmate.ecuad.ca'
  frontDoorProfile: 'reportmate-frontdoor'
  frontDoorEndpoint: 'reportmate-endpoint'
  
  # API URL (for frontend build args)
  apiBaseUrl: 'https://reportmate-functions-api.blackdune-79551938.canadacentral.azurecontainerapps.io'
  
  # Terraform Backend (Azure Blob Storage)
  terraformBackendRG: 'ecuadgitopsterraform'
  terraformBackendSA: 'ecuadgitopsterraform'
  terraformBackendContainer: 'terraform-state'
  terraformBackendKey: 'reportmate.tfstate'
  
  # Build Configuration
  vmImage: 'ubuntu-latest'
  terraformVersion: '1.6.0'

pool:
  vmImage: $(vmImage)

# =============================================================================
# STAGES
# =============================================================================
stages:
  # ===========================================================================
  # STAGE: PURGE ONLY (fast path)
  # ===========================================================================
  - stage: PurgeOnlyStage
    displayName: 'Purge CDN Only'
    condition: eq('${{ parameters.purgeOnly }}', true)
    
    jobs:
      - job: PurgeCDN
        displayName: 'Purge Azure Front Door'
        steps:
          - task: AzureCLI@2
            displayName: 'Purge Front Door Cache'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "üóëÔ∏è Purging Azure Front Door cache (async)..."
                az afd endpoint purge \
                  --resource-group $(resourceGroup) \
                  --profile-name $(frontDoorProfile) \
                  --endpoint-name $(frontDoorEndpoint) \
                  --content-paths "/*" \
                  --domains $(customDomain) \
                  --no-wait || true
                
                echo "‚úÖ Front Door cache purge triggered (async) for $(customDomain)"

  # ===========================================================================
  # STAGE: BUILD CONTAINERS
  # Replicates deploy-api.ps1 and deploy-app.ps1 build logic
  # ===========================================================================
  - stage: Build
    displayName: 'Build Container Images'
    condition: |
      and(
        succeeded(),
        ne('${{ parameters.purgeOnly }}', true),
        ne(variables['Build.Reason'], 'PullRequest')
      )
    
    jobs:
      - job: BuildContainers
        displayName: 'Build and Push to ACR'
        
        steps:
          # Checkout infrastructure repo (contains API code and Terraform)
          - checkout: infrastructure
            displayName: 'Checkout Infrastructure Repo'
            path: infrastructure
            fetchDepth: 0

          # Checkout web app repo (frontend code)
          - checkout: webapp
            displayName: 'Checkout Web App Repo'
            path: webapp
            fetchDepth: 0

          # Generate build tags (matches deploy-*.ps1 format)
          - bash: |
              set -e
              
              # Timestamp in YYYYMMDDHHMMSS format (matches PowerShell scripts)
              TIMESTAMP=$(date +%Y%m%d%H%M%S)
              BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)
              
              # Get git hashes from each repo
              INFRA_HASH=$(cd $(Pipeline.Workspace)/infrastructure && git rev-parse --short HEAD)
              WEBAPP_HASH=$(cd $(Pipeline.Workspace)/webapp && git rev-parse --short HEAD)
              
              # Frontend tag: YYYYMMDDHHMMSS-<webapp-hash> (matches deploy-app.ps1)
              FRONTEND_TAG="${TIMESTAMP}-${WEBAPP_HASH}"
              
              # API tag: YYYYMMDDHHMMSS-<infra-hash> (matches deploy-api.ps1 format)
              API_TAG="${TIMESTAMP}-${INFRA_HASH}"
              
              # Export as pipeline variables
              echo "##vso[task.setvariable variable=frontendTag;isOutput=true]${FRONTEND_TAG}"
              echo "##vso[task.setvariable variable=apiTag;isOutput=true]${API_TAG}"
              echo "##vso[task.setvariable variable=buildTime;isOutput=true]${BUILD_TIME}"
              echo "##vso[task.setvariable variable=infraHash;isOutput=true]${INFRA_HASH}"
              echo "##vso[task.setvariable variable=webappHash;isOutput=true]${WEBAPP_HASH}"
              echo "##vso[task.setvariable variable=timestamp;isOutput=true]${TIMESTAMP}"
              
              echo "=============================================="
              echo "BUILD TAGS GENERATED"
              echo "=============================================="
              echo "Timestamp: ${TIMESTAMP}"
              echo "Build Time: ${BUILD_TIME}"
              echo "Frontend Tag: ${FRONTEND_TAG} (webapp hash: ${WEBAPP_HASH})"
              echo "API Tag: ${API_TAG} (infra hash: ${INFRA_HASH})"
              echo "=============================================="
            displayName: 'Generate Build Tags'
            name: tags

          # Login to Azure Container Registry
          - task: AzureCLI@2
            displayName: 'Login to ACR'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "üîê Authenticating to Azure Container Registry..."
                az acr login --name $(containerRegistry)
                echo "‚úÖ ACR authentication successful"

          # =================================================================
          # BUILD FRONTEND (replicates deploy-app.ps1)
          # =================================================================
          - bash: |
              set -e
              cd $(Pipeline.Workspace)/webapp
              
              FULL_IMAGE="$(registryUrl)/$(frontendImage):$(tags.frontendTag)"
              LATEST_IMAGE="$(registryUrl)/$(frontendImage):latest"
              
              echo "=============================================="
              echo "BUILDING FRONTEND CONTAINER"
              echo "=============================================="
              echo "Image: ${FULL_IMAGE}"
              echo "Dockerfile: Dockerfile"
              echo "Context: $(Pipeline.Workspace)/webapp"
              echo "Force Build: ${{ parameters.forceBuild }}"
              echo "=============================================="
              
              # Build args match deploy-app.ps1 exactly
              BUILD_ARGS=(
                "--platform" "linux/amd64"
                "--build-arg" "IMAGE_TAG=$(tags.frontendTag)"
                "--build-arg" "BUILD_TIME=$(tags.buildTime)"
                "--build-arg" "BUILD_ID=$(tags.webappHash)"
                "--build-arg" "NEXT_PUBLIC_ENABLE_SIGNALR=true"
                "--build-arg" "NEXT_PUBLIC_API_BASE_URL=$(apiBaseUrl)"
                "--build-arg" "API_BASE_URL=$(apiBaseUrl)"
              )
              
              # Force build = no cache (matches -ForceBuild in PowerShell)
              if [ "${{ parameters.forceBuild }}" = "true" ]; then
                BUILD_ARGS+=("--no-cache" "--pull")
                echo "‚ö†Ô∏è Force build enabled - no Docker cache, pulling fresh base image"
              fi
              
              BUILD_ARGS+=("-t" "${FULL_IMAGE}" "-t" "${LATEST_IMAGE}" "-f" "Dockerfile" ".")
              
              echo "üî® Building frontend image..."
              docker build "${BUILD_ARGS[@]}"
              
              echo "üì§ Pushing frontend image..."
              docker push "${FULL_IMAGE}"
              docker push "${LATEST_IMAGE}"
              
              echo "‚úÖ Frontend container built and pushed successfully"
            displayName: 'Build Frontend Container'
            condition: eq('${{ parameters.deployFrontend }}', true)

          # =================================================================
          # BUILD API (replicates deploy-api.ps1)
          # =================================================================
          - bash: |
              set -e
              cd $(Pipeline.Workspace)/infrastructure/infrastructure/modules/api
              
              FULL_IMAGE="$(registryUrl)/$(apiImage):$(tags.apiTag)"
              LATEST_IMAGE="$(registryUrl)/$(apiImage):latest"
              
              echo "=============================================="
              echo "BUILDING API CONTAINER"
              echo "=============================================="
              echo "Image: ${FULL_IMAGE}"
              echo "Dockerfile: Dockerfile"
              echo "Context: $(Pipeline.Workspace)/infrastructure/infrastructure/modules/api"
              echo "Force Build: ${{ parameters.forceBuild }}"
              echo "=============================================="
              
              BUILD_ARGS=(
                "--platform" "linux/amd64"
              )
              
              # Force build = no cache
              if [ "${{ parameters.forceBuild }}" = "true" ]; then
                BUILD_ARGS+=("--no-cache" "--pull")
                echo "‚ö†Ô∏è Force build enabled - no Docker cache"
              fi
              
              BUILD_ARGS+=("-t" "${FULL_IMAGE}" "-t" "${LATEST_IMAGE}" "-f" "Dockerfile" ".")
              
              echo "üî® Building API image..."
              docker build "${BUILD_ARGS[@]}"
              
              echo "üì§ Pushing API image..."
              docker push "${FULL_IMAGE}"
              docker push "${LATEST_IMAGE}"
              
              echo "‚úÖ API container built and pushed successfully"
            displayName: 'Build API Container'
            condition: eq('${{ parameters.deployApi }}', true)

          # Save build metadata for downstream stages
          - bash: |
              mkdir -p $(Build.ArtifactStagingDirectory)
              cat > $(Build.ArtifactStagingDirectory)/build-metadata.json << EOF
              {
                "frontendTag": "$(tags.frontendTag)",
                "apiTag": "$(tags.apiTag)",
                "buildTime": "$(tags.buildTime)",
                "timestamp": "$(tags.timestamp)",
                "infraHash": "$(tags.infraHash)",
                "webappHash": "$(tags.webappHash)",
                "buildNumber": "$(Build.BuildNumber)",
                "frontendImage": "$(registryUrl)/$(frontendImage):$(tags.frontendTag)",
                "apiImage": "$(registryUrl)/$(apiImage):$(tags.apiTag)"
              }
              EOF
              
              echo "Build metadata saved:"
              cat $(Build.ArtifactStagingDirectory)/build-metadata.json
            displayName: 'Save Build Metadata'

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Build Metadata'
            inputs:
              targetPath: $(Build.ArtifactStagingDirectory)/build-metadata.json
              artifact: build-metadata
              publishLocation: pipeline

  # ===========================================================================
  # STAGE: TERRAFORM PLAN
  # ===========================================================================
  - stage: Plan
    displayName: 'Terraform Plan'
    dependsOn: Build
    condition: |
      and(
        not(failed()),
        ne('${{ parameters.purgeOnly }}', true),
        eq('${{ parameters.skipTerraform }}', false)
      )
    
    jobs:
      - job: TerraformPlan
        displayName: 'Plan Infrastructure Changes'
        
        steps:
          - checkout: infrastructure
            displayName: 'Checkout Infrastructure'
            path: infrastructure

          - task: TerraformInstaller@1
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)

          - task: DownloadPipelineArtifact@2
            displayName: 'Download Build Metadata'
            inputs:
              artifact: build-metadata
              path: $(Pipeline.Workspace)/metadata

          - bash: |
              FRONTEND_TAG=$(jq -r '.frontendTag' $(Pipeline.Workspace)/metadata/build-metadata.json)
              API_TAG=$(jq -r '.apiTag' $(Pipeline.Workspace)/metadata/build-metadata.json)
              
              echo "##vso[task.setvariable variable=frontendTag]${FRONTEND_TAG}"
              echo "##vso[task.setvariable variable=apiTag]${API_TAG}"
              
              echo "Image tags loaded from build:"
              echo "  Frontend: $(registryUrl)/$(frontendImage):${FRONTEND_TAG}"
              echo "  API: $(registryUrl)/$(apiImage):${API_TAG}"
            displayName: 'Load Image Tags'

          - task: AzureCLI@2
            displayName: 'Terraform Init'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              workingDirectory: $(Pipeline.Workspace)/infrastructure/infrastructure
              inlineScript: |
                terraform init \
                  -backend-config="resource_group_name=$(terraformBackendRG)" \
                  -backend-config="storage_account_name=$(terraformBackendSA)" \
                  -backend-config="container_name=$(terraformBackendContainer)" \
                  -backend-config="key=$(terraformBackendKey)"

          - task: AzureCLI@2
            displayName: 'Terraform Plan'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              workingDirectory: $(Pipeline.Workspace)/infrastructure/infrastructure
              inlineScript: |
                echo "Planning with image tags:"
                echo "  frontend_image_tag = $(frontendTag)"
                echo "  api_image_tag = $(apiTag)"
                
                terraform plan \
                  -var-file="terraform.tfvars" \
                  -var="frontend_image_tag=$(frontendTag)" \
                  -var="api_image_tag=$(apiTag)" \
                  -out=$(Build.ArtifactStagingDirectory)/tfplan
                
                echo ""
                echo "=============================================="
                echo "TERRAFORM PLAN COMPLETE"
                echo "=============================================="
                echo "Frontend: $(registryUrl)/$(frontendImage):$(frontendTag)"
                echo "API: $(registryUrl)/$(apiImage):$(apiTag)"
                echo "=============================================="

          - task: PublishPipelineArtifact@1
            displayName: 'Publish Terraform Plan'
            inputs:
              targetPath: $(Build.ArtifactStagingDirectory)/tfplan
              artifact: terraform-plan
              publishLocation: pipeline

  # ===========================================================================
  # STAGE: TERRAFORM APPLY
  # ===========================================================================
  - stage: Apply
    displayName: 'Terraform Apply'
    dependsOn: [Build, Plan]
    condition: |
      and(
        not(failed()),
        ne('${{ parameters.purgeOnly }}', true),
        ne(variables['Build.Reason'], 'PullRequest'),
        eq('${{ parameters.skipTerraform }}', false)
      )
    
    jobs:
      - deployment: TerraformApply
        displayName: 'Apply Infrastructure'
        environment: 'ReportMate-Production'  # Requires manual approval
        strategy:
          runOnce:
            deploy:
              steps:
                - checkout: infrastructure
                  displayName: 'Checkout Infrastructure'
                  path: infrastructure

                - task: TerraformInstaller@1
                  displayName: 'Install Terraform'
                  inputs:
                    terraformVersion: $(terraformVersion)

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Build Metadata'
                  inputs:
                    artifact: build-metadata
                    path: $(Pipeline.Workspace)/metadata

                - task: DownloadPipelineArtifact@2
                  displayName: 'Download Terraform Plan'
                  inputs:
                    artifact: terraform-plan
                    path: $(Pipeline.Workspace)/tfplan

                - bash: |
                    FRONTEND_TAG=$(jq -r '.frontendTag' $(Pipeline.Workspace)/metadata/build-metadata.json)
                    API_TAG=$(jq -r '.apiTag' $(Pipeline.Workspace)/metadata/build-metadata.json)
                    BUILD_TIME=$(jq -r '.buildTime' $(Pipeline.Workspace)/metadata/build-metadata.json)
                    
                    echo "##vso[task.setvariable variable=frontendTag]${FRONTEND_TAG}"
                    echo "##vso[task.setvariable variable=apiTag]${API_TAG}"
                    echo "##vso[task.setvariable variable=buildTime]${BUILD_TIME}"
                    
                    echo "=============================================="
                    echo "DEPLOYING"
                    echo "=============================================="
                    echo "Frontend: $(registryUrl)/$(frontendImage):${FRONTEND_TAG}"
                    echo "API: $(registryUrl)/$(apiImage):${API_TAG}"
                    echo "=============================================="
                  displayName: 'Load Build Metadata'

                - task: AzureCLI@2
                  displayName: 'Terraform Init'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: bash
                    scriptLocation: inlineScript
                    workingDirectory: $(Pipeline.Workspace)/infrastructure/infrastructure
                    inlineScript: |
                      terraform init \
                        -backend-config="resource_group_name=$(terraformBackendRG)" \
                        -backend-config="storage_account_name=$(terraformBackendSA)" \
                        -backend-config="container_name=$(terraformBackendContainer)" \
                        -backend-config="key=$(terraformBackendKey)"

                - task: AzureCLI@2
                  displayName: 'Terraform Apply'
                  inputs:
                    azureSubscription: $(azureSubscription)
                    scriptType: bash
                    scriptLocation: inlineScript
                    workingDirectory: $(Pipeline.Workspace)/infrastructure/infrastructure
                    inlineScript: |
                      terraform apply -auto-approve $(Pipeline.Workspace)/tfplan/tfplan
                      
                      echo ""
                      echo "=============================================="
                      echo "TERRAFORM APPLY COMPLETE"
                      echo "=============================================="

  # ===========================================================================
  # STAGE: UPDATE CONTAINER ENV VARS
  # Replicates the env var updates from deploy-app.ps1
  # ===========================================================================
  - stage: UpdateEnvVars
    displayName: 'Update Container Env Vars'
    dependsOn: Apply
    condition: |
      and(
        succeeded(),
        ne('${{ parameters.purgeOnly }}', true),
        eq('${{ parameters.deployFrontend }}', true)
      )
    
    jobs:
      - job: UpdateEnv
        displayName: 'Sync Environment Variables'
        
        steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Build Metadata'
            inputs:
              artifact: build-metadata
              path: $(Pipeline.Workspace)/metadata

          - task: AzureCLI@2
            displayName: 'Update Frontend Container Env Vars'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                # Load build metadata
                FRONTEND_TAG=$(jq -r '.frontendTag' $(Pipeline.Workspace)/metadata/build-metadata.json)
                BUILD_TIME=$(jq -r '.buildTime' $(Pipeline.Workspace)/metadata/build-metadata.json)
                WEBAPP_HASH=$(jq -r '.webappHash' $(Pipeline.Workspace)/metadata/build-metadata.json)
                
                echo "=============================================="
                echo "UPDATING CONTAINER ENVIRONMENT VARIABLES"
                echo "=============================================="
                echo "Container: $(frontendContainerApp)"
                echo "Tag: ${FRONTEND_TAG}"
                echo "Build Time: ${BUILD_TIME}"
                echo "Build ID: ${WEBAPP_HASH}"
                echo "=============================================="
                
                # Update env vars (matches deploy-app.ps1 exactly)
                az containerapp update \
                  --name $(frontendContainerApp) \
                  --resource-group $(resourceGroup) \
                  --set-env-vars \
                    "CONTAINER_IMAGE_TAG=${FRONTEND_TAG}" \
                    "BUILD_TIME=${BUILD_TIME}" \
                    "BUILD_ID=${WEBAPP_HASH}" \
                    "NEXT_PUBLIC_VERSION=${FRONTEND_TAG}" \
                    "NEXT_PUBLIC_BUILD_ID=${WEBAPP_HASH}" \
                    "NEXT_PUBLIC_BUILD_TIME=${BUILD_TIME}" \
                    "API_BASE_URL=$(apiBaseUrl)" \
                    "NEXT_PUBLIC_API_BASE_URL=$(apiBaseUrl)"
                
                echo "‚úÖ Environment variables updated"

          # Wait for revision to warm up (matches deploy-app.ps1)
          - bash: |
              echo "Waiting 30 seconds for new revision to warm up..."
              sleep 30
              echo "‚úÖ Warmup complete"
            displayName: 'Wait for Container Warmup'

  # ===========================================================================
  # STAGE: PURGE CDN
  # ===========================================================================
  - stage: PurgeCDN
    displayName: 'Purge Front Door Cache'
    dependsOn: UpdateEnvVars
    condition: |
      and(
        succeeded(),
        ne('${{ parameters.purgeOnly }}', true),
        eq('${{ parameters.deployFrontend }}', true)
      )
    
    jobs:
      - job: PurgeCache
        displayName: 'Purge Azure Front Door'
        
        steps:
          - task: AzureCLI@2
            displayName: 'Purge Front Door Cache'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "üóëÔ∏è Purging Azure Front Door cache..."
                
                az afd endpoint purge \
                  --resource-group $(resourceGroup) \
                  --profile-name $(frontDoorProfile) \
                  --endpoint-name $(frontDoorEndpoint) \
                  --content-paths "/*" \
                  --domains $(customDomain) \
                  --no-wait || true
                
                echo "‚úÖ Front Door cache purge triggered (async) for $(customDomain)"

  # ===========================================================================
  # STAGE: HEALTH CHECK
  # ===========================================================================
  - stage: HealthCheck
    displayName: 'Health Check'
    dependsOn: [UpdateEnvVars, PurgeCDN]
    condition: |
      and(
        succeeded(),
        ne('${{ parameters.purgeOnly }}', true)
      )
    
    jobs:
      - job: ValidateDeployment
        displayName: 'Validate Deployment'
        
        steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Build Metadata'
            inputs:
              artifact: build-metadata
              path: $(Pipeline.Workspace)/metadata

          - bash: |
              FRONTEND_TAG=$(jq -r '.frontendTag' $(Pipeline.Workspace)/metadata/build-metadata.json)
              API_TAG=$(jq -r '.apiTag' $(Pipeline.Workspace)/metadata/build-metadata.json)
              echo "##vso[task.setvariable variable=frontendTag]${FRONTEND_TAG}"
              echo "##vso[task.setvariable variable=apiTag]${API_TAG}"
            displayName: 'Load Build Metadata'

          # Health check frontend (matches deploy-app.ps1)
          - task: AzureCLI@2
            displayName: 'Check Frontend Health'
            condition: eq('${{ parameters.deployFrontend }}', true)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "üîç Testing frontend at https://$(customDomain)..."
                
                for i in {1..5}; do
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$(customDomain)" || echo "000")
                  if [ "$STATUS" = "200" ]; then
                    echo "‚úÖ Frontend is healthy (HTTP $STATUS)"
                    break
                  fi
                  echo "Attempt $i: HTTP $STATUS, retrying in 10s..."
                  sleep 10
                done
                
                if [ "$STATUS" != "200" ]; then
                  echo "##vso[task.logissue type=warning]Frontend health check returned HTTP $STATUS"
                fi

          # Health check API (matches deploy-api.ps1)
          - task: AzureCLI@2
            displayName: 'Check API Health'
            condition: eq('${{ parameters.deployApi }}', true)
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: bash
              scriptLocation: inlineScript
              inlineScript: |
                echo "üîç Testing API at $(apiBaseUrl)/api/health..."
                
                for i in {1..5}; do
                  STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$(apiBaseUrl)/api/health" || echo "000")
                  if [ "$STATUS" = "200" ]; then
                    echo "‚úÖ API is healthy (HTTP $STATUS)"
                    break
                  fi
                  echo "Attempt $i: HTTP $STATUS, retrying in 10s..."
                  sleep 10
                done
                
                if [ "$STATUS" != "200" ]; then
                  echo "##vso[task.logissue type=warning]API health check returned HTTP $STATUS"
                fi

          # Deployment summary (matches deploy-app.ps1 output)
          - bash: |
              echo ""
              echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
              echo "                    DEPLOYMENT SUMMARY"
              echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
              echo ""
              echo "Build Number: $(Build.BuildNumber)"
              echo ""
              echo "Container Images:"
              echo "  Frontend: $(registryUrl)/$(frontendImage):$(frontendTag)"
              echo "  API:      $(registryUrl)/$(apiImage):$(apiTag)"
              echo ""
              echo "Source Repositories:"
              echo "  Web App:        github.com/reportmate/reportmate-app-web"
              echo "  Infrastructure: github.com/reportmate/terraform-azurerm-reportmate"
              echo ""
              echo "URLs:"
              echo "  Frontend: https://$(customDomain)"
              echo "  API:      $(apiBaseUrl)"
              echo ""
              echo "Next Steps:"
              echo "  ‚Ä¢ Open https://$(customDomain) in an incognito window to verify"
              echo "  ‚Ä¢ Visit /settings ‚Üí check CONTAINER_IMAGE_TAG matches $(frontendTag)"
              echo "  ‚Ä¢ If browser shows cached content, hard refresh (Ctrl+F5)"
              echo ""
              echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
              echo "                         DONE"
              echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            displayName: 'Deployment Summary'
